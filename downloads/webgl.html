<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width height=device-height initial-scale=1" />
    <title>DEMO</title>
    <script type="text/javascript" src="jquery-2.1.0.min.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="buffer.js"></script>
    <script type="text/javascript" src="texture.js"></script>
</head>
<body style="margin:0px">
    <canvas id="glcanvas" width="512" height="512" style="width:100%;height:100%">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
    </canvas>
    <div id="info_panel" style="position:fixed;left:0px;top:0px;background-color:rgba(255, 255, 255, 0.8)">
        Info
    </div>

    

    <script id="shader-vs" type="x-shader/x-vertex">
    attribute   vec2    vertexPosition;
    attribute   vec2    textureCoord;
    varying     mediump vec2    vTextureCoord;
    varying     mediump vec2    vColorCenter;

    //uniform mat4 uMVMatrix;
    //uniform mat4 uPMatrix;

    void main(void) {
        //gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position     = vec4(vertexPosition, 0.0, 1.0);
        vTextureCoord   = textureCoord;
    }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">

    uniform     mediump     int     flag;
    uniform     mediump     vec4    color;
    uniform     mediump     vec2    posVec;
    uniform     mediump     float   ratio;
    uniform     sampler2D   samplerBack;
    uniform     sampler2D   samplerFront;
    varying     mediump vec2    vTextureCoord;

    void main(void) {
        if (flag == 0)
        {
            gl_FragColor = abs(texture2D(samplerBack, vTextureCoord)  - vec4(0.01, 0.01, 0.01, 0));
        }
        else if (flag == 1)
        {
            mediump float d = sqrt(((posVec[0]-gl_FragCoord[0])*ratio) * ((posVec[0]-gl_FragCoord[0])*ratio) + (posVec[1]-gl_FragCoord[1]) * (posVec[1]-gl_FragCoord[1]));
            if(d < 80.0){
                gl_FragColor = texture2D(samplerFront, vTextureCoord);
            }else{
                gl_FragColor = abs(texture2D(samplerBack, vTextureCoord)  - vec4(0.01, 0.01, 0.01, 0));
            }
        }
        else if (flag == 2)
        {
            gl_FragColor = texture2D(samplerBack, vTextureCoord);
        }
        else
        {
            gl_FragColor = vec4(0,0,0,1);
        }
    }
    </script>

    <script type="text/javascript" language="javascript">
    var gl                  = null;
    var shader              = null;
    var buffers             = {};
    var imageTexture        = null;
    var frameBufferTexture  = null;

    var cx = 0;
    var cy = 0;
    var cw = $("#glcanvas").attr('width') || 512;
    var ch = $("#glcanvas").attr('height') || 512;
    var vw = cw;
    var vh = ch; 
    var fading = 100;
    var hasNew = false;

    var frameCount = 0;

    function initWebGL(canvas) {
        // 创建全局变量
        gl = null;
        try {
            // 尝试创建标准上下文，如果失败，回退到试验性上下文
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        }
        catch(e) {}
        // 如果没有GL上下文，马上放弃
        if (!gl) {
            alert("Unable to initialize WebGL. Your browser may not support it.");
        }
        return gl;
    }

    function initShaders (gl) {
        shader = new GLShader(gl);
        shader.setShaderScript('shader-vs', 'shader-fs');
        return shader;
    }

    function initTextures(gl) {
        imageTexture = new GLTexture(gl);
        imageTexture.loadImage('texture.png');
        frameBufferTexture = new GLFrameBufferTexture(gl, null, cw, ch);
    }

    function initBuffers(gl) {
        buffers = {};
        buffers.rectA = new GLFloatBuffer(gl, gl.ARRAY_BUFFER, [
            -1,   1,
             1,   1,
             1,   -1,
            -1,   -1,
        ]);

        buffers.rectB = new GLFloatBuffer(gl, gl.ARRAY_BUFFER, [
             0,   0,
             1,   0,
             1,  -1,
             0,  -1,
        ]);

        buffers.texCoord = new GLFloatBuffer(gl, gl.ARRAY_BUFFER, [
             0,   1,
             1,   1,
             1,   0,
             0,   0,
        ]);

        return buffers;
    }

    function initScene(gl) {
        if (gl) {  // 只有在 WebGL 可用的时候才继续
            gl.clearColor(0.0, 0.0, 0.0, 1.0);                      // 设置擦除颜色为黑色，不透明
            gl.enable(gl.DEPTH_TEST);                               // 开启“深度测试”, Z-缓存
            gl.depthFunc(gl.LEQUAL);                                // 这里设置深度测试，满足（深度小或相等的时候才渲染）
            gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // 清除深度缓存的颜色
        }
    }

    function drawScene() {

        // ---------------------------------------------------------------------
        frameBufferTexture.begin();
        
        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        frameBufferTexture.activeWith(shader, 0, "samplerBack");
        imageTexture.activeWith(shader, 1, "samplerFront");

        if(hasNew){
            buffers.rectA.bindAttrib(shader.attrib('vertexPosition'), 2);
            buffers.texCoord.bindAttrib(shader.attrib('textureCoord'), 2);
            gl.uniform1i(shader.uniform('flag'), 1);
            gl.uniform4f(shader.uniform('color'), 1.0, 1.0, 1.0, 1.0);
            gl.uniform2f(shader.uniform('posVec'), cx, cy);
            gl.uniform1f(shader.uniform('ratio'), vw / vh);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            hasNew = false;
        }else{
            buffers.rectA.bindAttrib(shader.attrib('vertexPosition'), 2);
            buffers.texCoord.bindAttrib(shader.attrib('textureCoord'), 2);
            gl.uniform1i(shader.uniform('flag'), 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }

        frameBufferTexture.end();
        // ---------------------------------------------------------------------
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        frameBufferTexture.activeWith(shader, 0, "samplerBack");

        buffers.rectA.bindAttrib(shader.attrib('vertexPosition'), 2);
        buffers.texCoord.bindAttrib(shader.attrib('textureCoord'), 2);
        gl.uniform1i(shader.uniform('flag'), 2);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        // ---------------------------------------------------------------------
        frameCount ++;
    }

    function refreshPage () {
        if (fading > 0){
            fading -= 1;
            drawScene();
        }
        requestAnimationFrame(refreshPage);
    }

    function showInfo () {
        $('#info_panel').text('Info cx=' + cx + ' cy=' + cy + ' FPS=' + frameCount);
        frameCount = 0;
    }

    $(window).resize(function(){
        vw = $("#glcanvas").width();
        vh = $("#glcanvas").height();
        if(gl){
            gl.viewport(0, 0, cw, ch);
            drawScene();
        }
    });

    $(document).ready(function () {
        var canvas = document.getElementById("glcanvas");
        initWebGL(canvas);      // 初始化 GL 上下文
        initShaders(gl);
        initTextures(gl);
        initBuffers(gl);
        initScene(gl);
        $(window).resize();
        $('#glcanvas').click(function (e) {
            cx = e.pageX * cw / vw;
            cy = ch - e.pageY * ch / vh;
            hasNew = true;
            fading = 100;
        });
        window.setInterval(showInfo, 1000);
        refreshPage();
    });
    </script>
</body>
</html>